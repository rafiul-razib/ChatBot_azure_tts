from flask import Flask, render_template, request, jsonify, session
from dotenv import load_dotenv
import google.generativeai as genai
import json
import os
import re
from openai import OpenAI
from pathlib import Path
import uuid

# --------------------------------------------------
# Setup
# --------------------------------------------------
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "dev-secret")

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# --------------------------------------------------
# Configure Gemini
# --------------------------------------------------
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
model = genai.GenerativeModel("gemini-2.5-flash")

# --------------------------------------------------
# Paths
# --------------------------------------------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PRODUCTS_PATH = os.path.join(BASE_DIR, "products.json")
ARTICLE_PATH = os.path.join(BASE_DIR, "article.txt")

# --------------------------------------------------
# Load product data
# --------------------------------------------------
try:
    with open(PRODUCTS_PATH, "r", encoding="utf-8") as f:
        PRODUCT_DATA = json.load(f)
except Exception as e:
    print("❌ Failed to load products.json:", e)
    PRODUCT_DATA = {"brands": []}

print("✅ Brands loaded:", len(PRODUCT_DATA.get("brands", [])))

# --------------------------------------------------
# Load company article
# --------------------------------------------------
try:
    with open(ARTICLE_PATH, "r", encoding="utf-8") as f:
        ARTICLE_TEXT = f.read()
except Exception as e:
    print("❌ Failed to load article.txt:", e)
    ARTICLE_TEXT = ""

# --------------------------------------------------
# Utility functions
# --------------------------------------------------
def get_all_products():
    products = []
    for brand in PRODUCT_DATA.get("brands", []):
        brand_name = brand.get("brand_name", "Unknown Brand")
        for product in brand.get("products", []):
            p = product.copy()
            p["brand"] = brand_name
            products.append(p)
    return products


def format_products_for_prompt(products):
    formatted = ""
    for p in products:
        formatted += f"""
Product Name: {p.get('name', 'N/A')}
Brand: {p.get('brand', 'N/A')}
Category: {p.get('category', 'N/A')}
Features: {p.get('features', 'N/A')}
Usage Instructions: {p.get('usage_instructions', 'N/A')}
Ingredients: {', '.join(p.get('ingredients', []))}
Price: {p.get('price_bdt', 'N/A')} BDT
Suitability: {p.get('suitability', 'N/A')}
---
"""
    return formatted


def detect_language(text):
    """Detect Bangla vs English"""
    return "bn" if re.search(r"[\u0980-\u09FF]", text) else "en"

# --------------------------------------------------
# Routes
# --------------------------------------------------
@app.route("/")
def home():
    return render_template("index.html")


@app.route("/chat", methods=["POST"])
def chat():
    data = request.get_json(silent=True) or {}

    user_message = data.get("message", "").strip()
    frontend_lang = data.get("lang")
    temperature = float(data.get("temperature", 0.6))

    if not user_message:
        return jsonify({"reply": "Please ask a question.", "lang": "en"})

    lang = frontend_lang or detect_language(user_message)

    # --------------------------------------------------
    # Session memory
    # --------------------------------------------------
    if "chat_history" not in session:
        session["chat_history"] = []

    if "system_instruction" not in session:
        products_context = format_products_for_prompt(get_all_products())
        session["system_instruction"] = f"""
You are a professional customer service officer for Lira Cosmetics Ltd.

Company Info:
{ARTICLE_TEXT}

Products:
{products_context}
"""

    system_instruction = session["system_instruction"]

    language_rule = (
        "Reply ONLY in Bangla. Use polite, natural Bangla."
        if lang == "bn"
        else "Reply ONLY in English. Use polite, natural English."
    )

    prompt = f"""
{system_instruction}

Rules:
- Answer ONLY based on the provided company and product data.
- Keep answers SHORT and voice-friendly (2–3 sentences).
- Do NOT use symbols, bullets, or emojis.
- Be polite, clear, and customer-friendly.
- Do NOT invent information.
- {language_rule}

User Question:
{user_message}
"""

    try:
        chat_obj = model.start_chat(history=session["chat_history"])

        response = chat_obj.send_message(
            prompt,
            generation_config={
                "temperature": temperature,
                "top_p": 0.9,
                "top_k": 40,
                "max_output_tokens": 220
            }
        )

        reply = response.text.strip()

        # Serialize history safely
        session["chat_history"] = [
            {
                "role": msg.role,
                "parts": [{"text": part.text} for part in msg.parts]
            }
            for msg in chat_obj.history
        ]

    except Exception as e:
        print("❌ Gemini error:", e)
        reply = (
            "এই মুহূর্তে উত্তর দিতে সমস্যা হচ্ছে। দয়া করে একটু পরে চেষ্টা করুন।"
            if lang == "bn"
            else "I'm having trouble answering right now. Please try again."
        )

    return jsonify({"reply": reply, "lang": lang})

# --------------------------------------------------
# OpenAI TTS Route (FINAL)
# --------------------------------------------------
TTS_DIR = Path("static/tts")
TTS_DIR.mkdir(parents=True, exist_ok=True)

@app.route("/tts", methods=["POST"])
def tts():
    data = request.get_json(silent=True) or {}
    text = data.get("text", "").strip()

    if not text:
        return jsonify({"error": "No text provided"}), 400

    try:
        audio_path = TTS_DIR / f"{uuid.uuid4().hex}.mp3"

        with client.audio.speech.with_streaming_response.create(
            model="gpt-4o-mini-tts",
            voice="alloy",
            input=text
        ) as response:
            response.stream_to_file(audio_path)

        return jsonify({
            "audio_url": f"/static/tts/{audio_path.name}"
        })

    except Exception as e:
        print("❌ TTS generation failed:", e)
        return jsonify({"error": "TTS generation failed"}), 500

# --------------------------------------------------
# Run App
# --------------------------------------------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
